# Feature 2.7: Viewport-Based Geometry Loading

**Status**: Not Started
**Dependencies**: Feature 2 Phase 1 (Sidebar + Track List)
**Estimated Time**: 3-4 days
**Priority**: High (performance critical with 100+ tracks)

---

## Goal

Implement intelligent viewport-based geometry loading: only load track geometries that are visible in the current map viewport (+ 100% padding), with incremental loading to avoid refetching already-loaded tracks.

---

## Context

**Current Behavior:**
- All track geometries load on page load (via POST /api/v1/tracks/geometry)
- Works fine with <20 tracks
- With 100+ tracks at Chapel Hill zoom: slow initial load, huge JSON payload

**You're Adding:**
- R*Tree spatial queries to find tracks in viewport
- Incremental geometry loading (track what's already loaded)
- Viewport change detection
- Batch fetch only NEW tracks as user pans/zooms

---

## Architecture Decision

**Incremental Loading with Tracked IDs:**
```typescript
const [loadedTrackIds, setLoadedTrackIds] = useState<Set<number>>(new Set());
const [allGeometries, setAllGeometries] = useState<TrackGeometry[]>([]);

// On viewport change:
// 1. Query R*Tree for track IDs in viewport
// 2. Filter out already-loaded IDs
// 3. Batch fetch only new geometries
// 4. Accumulate (don't replace) geometries
```

**Benefits:**
- Initial load: Only tracks in viewport (fast)
- Pan 10%: Only fetch 1-2 new tracks (efficient)
- No redundant fetches
- Works with hundreds of tracks

---

## Acceptance Criteria

- [ ] New endpoint: POST /api/v1/spatial/viewport (returns track IDs)
- [ ] R*Tree spatial query with 100% padding
- [ ] Viewport change detection (MapLibre moveend event)
- [ ] Track which geometries already loaded (Set<number>)
- [ ] Only fetch geometries not in loaded set
- [ ] Accumulate geometries (merge, don't replace)
- [ ] Performance: Smooth panning with 200+ tracks
- [ ] Initial load only fetches ~50 tracks in viewport (not all 200)

---

## Implementation Sequence

### Step 1: Create Spatial Service

**Create `backend/services/spatial_service.py`:**
```python
from typing import List
from ..db.database import Database

class SpatialService:
    def __init__(self, db: Database):
        self.db = db

    def find_tracks_in_viewport(
        self,
        min_lat: float,
        max_lat: float,
        min_lon: float,
        max_lon: float,
        padding_percent: float = 1.0
    ) -> List[int]:
        """Find track IDs intersecting viewport with padding"""
        lat_range = max_lat - min_lat
        lon_range = max_lon - min_lon

        padded_min_lat = min_lat - (lat_range * padding_percent / 2)
        padded_max_lat = max_lat + (lat_range * padding_percent / 2)
        padded_min_lon = min_lon - (lon_range * padding_percent / 2)
        padded_max_lon = max_lon + (lon_range * padding_percent / 2)

        with self.db.get_connection() as conn:
            cursor = conn.execute("""
                SELECT id FROM track_spatial
                WHERE max_lat >= ? AND min_lat <= ?
                  AND max_lon >= ? AND min_lon <= ?
            """, (padded_min_lat, padded_max_lat, padded_min_lon, padded_max_lon))

            return [row[0] for row in cursor.fetchall()]
```

---

### Step 2: Add Spatial Query Endpoint

**Add to `backend/api/models.py`:**
```python
class ViewportRequest(BaseModel):
    min_lat: float
    max_lat: float
    min_lon: float
    max_lon: float

class ViewportResponse(BaseModel):
    track_ids: List[int]
```

**Add to `backend/api/routes.py`:**
```python
from ..services.spatial_service import SpatialService

spatial_service = SpatialService(db)

@router.post("/spatial/viewport", response_model=ViewportResponse)
async def tracks_in_viewport(request: ViewportRequest):
    track_ids = spatial_service.find_tracks_in_viewport(
        request.min_lat,
        request.max_lat,
        request.min_lon,
        request.max_lon
    )
    return ViewportResponse(track_ids=track_ids)
```

---

### Step 3: Add Viewport Tracking to Map Component

**Update `Map.tsx`:**
```typescript
interface MapProps {
  geometries: TrackGeometry[];
  onViewportChange: (bounds: ViewportBounds) => void;
}

export function Map({ geometries, onViewportChange }: MapProps) {
  useEffect(() => {
    if (!map.current || !mapLoaded) return;

    const handleMoveEnd = () => {
      const bounds = map.current.getBounds();
      onViewportChange({
        min_lat: bounds.getSouth(),
        max_lat: bounds.getNorth(),
        min_lon: bounds.getWest(),
        max_lon: bounds.getEast()
      });
    };

    // Debounce to avoid excessive queries
    let timeoutId: number;
    const debouncedMoveEnd = () => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(handleMoveEnd, 300);
    };

    map.current.on('moveend', debouncedMoveEnd);

    // Get initial viewport
    handleMoveEnd();

    return () => {
      map.current?.off('moveend', debouncedMoveEnd);
      clearTimeout(timeoutId);
    };
  }, [mapLoaded, onViewportChange]);

  // ... rest of component
}
```

---

### Step 4: Implement Incremental Loading in App.tsx

```typescript
const [loadedTrackIds, setLoadedTrackIds] = useState<Set<number>>(new Set());
const [allGeometries, setAllGeometries] = useState<TrackGeometry[]>([]);
const [viewport, setViewport] = useState<ViewportBounds | null>(null);

// Query tracks in viewport
const { data: tracksInViewport = [] } = useQuery({
  queryKey: ['viewport-tracks', viewport],
  queryFn: async () => {
    if (!viewport) return [];
    const response = await fetch('api/v1/spatial/viewport', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(viewport)
    });
    const data = await response.json();
    return data.track_ids;
  },
  enabled: !!viewport
});

// Load only new geometries
useEffect(() => {
  const newTrackIds = tracksInViewport.filter(id => !loadedTrackIds.has(id));

  if (newTrackIds.length > 0) {
    getTrackGeometries(newTrackIds).then(newGeometries => {
      setAllGeometries(prev => [...prev, ...newGeometries]);
      setLoadedTrackIds(prev => new Set([...prev, ...newTrackIds]));
    });
  }
}, [tracksInViewport]);

// Filter for visibility
const visibleGeometries = useMemo(() => {
  const visibleIds = new Set(
    tracks.filter(track => track.visible).map(track => track.id)
  );
  return allGeometries.filter(geometry => visibleIds.has(geometry.track_id));
}, [tracks, allGeometries]);
```

---

## Testing

- [ ] Initial load: Only ~50 tracks in viewport
- [ ] Pan map: New tracks load smoothly
- [ ] Pan back: No refetch (already loaded)
- [ ] R*Tree query with 100% padding works
- [ ] Performance with 200+ tracks: smooth panning
- [ ] Network tab: Only new track IDs fetched

---

**Prompt Version**: 1.0
**Created**: After Feature 2 Phase 1, split from 02.5
