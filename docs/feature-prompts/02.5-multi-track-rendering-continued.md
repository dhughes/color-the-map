# Feature 2.5: Multi-Track Rendering - Advanced Features

**Status**: Not Started
**Dependencies**: Feature 2 Phase 1 (Sidebar + Track List)
**Estimated Time**: 3-4 days
**Priority**: Medium-High

---

## Goal

Add advanced track management features: track selection with visual highlighting, viewport-based geometry loading for performance with hundreds of tracks, and resizable sidebar.

---

## Context

**Already Implemented in Feature 2 Phase 1:**
- Right sidebar with track list (350px fixed)
- Track list items showing: name, activity type, eye icon
- Visibility toggle (eye icon updates `visible` field)
- Map renders only visible tracks
- Mobile responsive (< 640px hides sidebar)
- Sorted by date (newest first)

**You're Adding:**
- Track selection (single-click on track list item)
- Selected track visual highlighting on map (brighter + thicker)
- Viewport-based geometry loading (only load tracks in view + 100% padding)
- R*Tree spatial queries for performance
- Incremental loading (track which geometries already loaded, only fetch new)
- Resizable sidebar with drag handle
- Optional: Persist sidebar width in localStorage

---

## Acceptance Criteria

- [ ] Clicking track in list selects it (highlights in list)
- [ ] Clicking map background deselects (optional)
- [ ] Selected track highlighted on map: brighter magenta (#FF66FF) + width 5px
- [ ] Unselected tracks: normal magenta (#FF00FF) + width 3px
- [ ] Only tracks in viewport (+ 100% padding) have geometries loaded
- [ ] R*Tree spatial query: POST /api/v1/spatial/viewport
- [ ] Incremental loading: track loaded IDs, only fetch new geometries
- [ ] Sidebar resizable with drag handle (min 250px, max 600px)
- [ ] Sidebar width defaults to 350px (no localStorage persistence)
- [ ] Performance: 100+ tracks with smooth viewport panning

---

## Implementation Sequence

### Step 1: Add Spatial Query Endpoint

**Create spatial service (`backend/services/spatial_service.py`):**
```python
from typing import List
from ..db.database import Database

class SpatialService:
    def __init__(self, db: Database):
        self.db = db

    def find_tracks_in_viewport(
        self,
        min_lat: float,
        max_lat: float,
        min_lon: float,
        max_lon: float,
        padding_percent: float = 1.0
    ) -> List[int]:
        """Find track IDs intersecting viewport with padding"""
        lat_range = max_lat - min_lat
        lon_range = max_lon - min_lon

        padded_min_lat = min_lat - (lat_range * padding_percent / 2)
        padded_max_lat = max_lat + (lat_range * padding_percent / 2)
        padded_min_lon = min_lon - (lon_range * padding_percent / 2)
        padded_max_lon = max_lon + (lon_range * padding_percent / 2)

        with self.db.get_connection() as conn:
            cursor = conn.execute("""
                SELECT id FROM track_spatial
                WHERE max_lat >= ? AND min_lat <= ?
                  AND max_lon >= ? AND min_lon <= ?
            """, (padded_min_lat, padded_max_lat, padded_min_lon, padded_max_lon))

            return [row[0] for row in cursor.fetchall()]
```

**Add endpoint to `backend/api/routes.py`:**
```python
from pydantic import BaseModel

class ViewportRequest(BaseModel):
    min_lat: float
    max_lat: float
    min_lon: float
    max_lon: float

@router.post("/spatial/viewport")
async def tracks_in_viewport(request: ViewportRequest):
    spatial_service = SpatialService(db)
    track_ids = spatial_service.find_tracks_in_viewport(
        request.min_lat,
        request.max_lat,
        request.min_lon,
        request.max_lon
    )
    return {"track_ids": track_ids}
```

---

### Step 2: Implement Selection State Management

**Create selection context (`frontend/src/context/SelectionContext.tsx`):**
```typescript
import { createContext, useContext, useState, ReactNode } from 'react'

interface SelectionContextType {
  selectedTrackId: number | null
  setSelectedTrackId: (id: number | null) => void
}

const SelectionContext = createContext<SelectionContextType | null>(null)

export function SelectionProvider({ children }: { children: ReactNode }) {
  const [selectedTrackId, setSelectedTrackId] = useState<number | null>(null)

  return (
    <SelectionContext.Provider value={{ selectedTrackId, setSelectedTrackId }}>
      {children}
    </SelectionContext.Provider>
  )
}

export const useSelection = () => {
  const context = useContext(SelectionContext)
  if (!context) throw new Error('useSelection must be within SelectionProvider')
  return context
}
```

---

### Step 3: Implement Viewport-Based Geometry Loading

**Update Map component to track viewport and loaded IDs:**

```typescript
const [loadedTrackIds, setLoadedTrackIds] = useState<Set<number>>(new Set())
const [viewport, setViewport] = useState<ViewportBounds | null>(null)

// Track viewport changes
useEffect(() => {
  if (!map.current) return

  const handleMoveEnd = () => {
    const bounds = map.current.getBounds()
    setViewport({
      min_lat: bounds.getSouth(),
      max_lat: bounds.getNorth(),
      min_lon: bounds.getWest(),
      max_lon: bounds.getEast()
    })
  }

  map.current.on('moveend', handleMoveEnd)

  // Set initial viewport
  handleMoveEnd()

  return () => {
    map.current?.off('moveend', handleMoveEnd)
  }
}, [mapLoaded])

// Query tracks in viewport
const { data: tracksInViewport = [] } = useQuery({
  queryKey: ['viewport-tracks', viewport],
  queryFn: () => getTracksInViewport(viewport!),
  enabled: !!viewport
})

// Load geometries for tracks we don't have yet
useEffect(() => {
  const newTrackIds = tracksInViewport.filter(id => !loadedTrackIds.has(id))

  if (newTrackIds.length > 0) {
    getTrackGeometries(newTrackIds).then(newGeometries => {
      setGeometries(prev => [...prev, ...newGeometries])
      setLoadedTrackIds(prev => new Set([...prev, ...newTrackIds]))
    })
  }
}, [tracksInViewport])
```

---

### Step 4: Add Selection Highlighting to Map

**Update Map.tsx layer paint properties:**
```typescript
mapInstance.addLayer({
  id: 'track-lines',
  type: 'line',
  source: 'tracks',
  paint: {
    'line-color': [
      'case',
      ['==', ['get', 'id'], selectedTrackId || -1],
      '#FF66FF',  // Brighter magenta for selected
      '#FF00FF'   // Normal magenta
    ],
    'line-width': [
      'case',
      ['==', ['get', 'id'], selectedTrackId || -1],
      5,  // Thicker for selected
      3
    ],
    'line-opacity': 0.85
  }
})
```

---

### Step 5: Implement Resizable Sidebar

**Add resize handle component:**
```typescript
export function ResizeHandle({ onResize }: { onResize: (width: number) => void }) {
  const [isResizing, setIsResizing] = useState(false)

  const handleMouseDown = () => setIsResizing(true)

  useEffect(() => {
    if (!isResizing) return

    const handleMouseMove = (e: MouseEvent) => {
      const newWidth = window.innerWidth - e.clientX
      const clampedWidth = Math.min(Math.max(newWidth, 250), 600)
      onResize(clampedWidth)
    }

    const handleMouseUp = () => setIsResizing(false)

    document.addEventListener('mousemove', handleMouseMove)
    document.addEventListener('mouseup', handleMouseUp)

    return () => {
      document.removeEventListener('mousemove', handleMouseMove)
      document.removeEventListener('mouseup', handleMouseUp)
    }
  }, [isResizing, onResize])

  return (
    <div
      className="resize-handle"
      onMouseDown={handleMouseDown}
      style={{
        position: 'absolute',
        left: 0,
        top: 0,
        bottom: 0,
        width: '4px',
        cursor: 'col-resize',
        background: isResizing ? '#999' : 'transparent'
      }}
    />
  )
}
```

---

## Testing

- [ ] Track selection works from list
- [ ] Selected track highlighted on map
- [ ] Viewport query returns correct track IDs
- [ ] Only new geometries loaded on viewport change
- [ ] Performance: pan across map with 100+ tracks
- [ ] Sidebar resizes between 250-600px
- [ ] Sidebar defaults to 350px on reload

---

**Prompt Version**: 1.0
**Created**: After Feature 2 Phase 1 scoping decision
